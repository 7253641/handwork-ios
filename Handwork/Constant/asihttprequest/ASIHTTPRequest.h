//
//  ASIHTTPRequest.h
//
//  Created by Ben Copsey on 04/10/2007.
//  Copyright 2007-2011 All-Seeing Interactive. All rights reserved.
//
//  A guide to the main features is available at:
//  http://allseeing-i.com/ASIHTTPRequest
//
//  Portions are based on the ImageClient example from Apple:
//  See: http://developer.apple.com/samplecode/ImageClient/listing37.html

#import <Foundation/Foundation.h>
#if TARGET_OS_IPHONE
	#import <CFNetwork/CFNetwork.h>
	#if __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_4_0
	#import <UIKit/UIKit.h> // Necessary for background task support
	#endif
#endif

#import <stdio.h>
#import "ASIHTTPRequestConfig.h"
#import "ASIHTTPRequestDelegate.h"
#import "ASIProgressDelegate.h"
#import "ASICacheDelegate.h"

@class ASIDataDecompressor;

extern NSString *ASIHTTPRequestVersion;

// Make targeting different platforms more reliable
// See: http://www.blumtnwerx.com/blog/2009/06/cross-sdk-code-hygiene-in-xcode/
#ifndef __IPHONE_3_2
	#define __IPHONE_3_2 30200
#endif
#ifndef __IPHONE_4_0
	#define __IPHONE_4_0 40000
#endif
#ifndef __MAC_10_5
	#define __MAC_10_5 1050
#endif
#ifndef __MAC_10_6
	#define __MAC_10_6 1060
#endif

typedef enum _ASIAuthenticationState {
	ASINoAuthenticationNeededYet = 0,
	ASIHTTPAuthenticationNeeded = 1,
	ASIProxyAuthenticationNeeded = 2
} ASIAuthenticationState;

typedef enum _ASINetworkErrorType {
    ASIConnectionFailureErrorType = 1,
    ASIRequestTimedOutErrorType = 2,
    ASIAuthenticationErrorType = 3,
    ASIRequestCancelledErrorType = 4,
    ASIUnableToCreateRequestErrorType = 5,
    ASIInternalErrorWhileBuildingRequestType  = 6,
    ASIInternalErrorWhileApplyingCredentialsType  = 7,
	ASIFileManagementError = 8,
	ASITooMuchRedirectionErrorType = 9,
	ASIUnhandledExceptionError = 10,
	ASICompressionError = 11
	
} ASINetworkErrorType;


// The error domain that all errors generated by ASIHTTPRequest use
// 错误ASIHTTPRequest生成的所有错误使用的域
extern NSString* const NetworkRequestErrorDomain;

/*
 * You can use this number to throttle upload and download bandwidth in iPhone OS apps send or receive a large amount of data
 *您可以使用这个数字来节流上传和下载带宽在iPhone OS应用程序发送或接收大量的数据
 */


/*
 * This may help apps that might otherwise be rejected for inclusion into the app store for using excessive bandwidth
 *这可能有助于应用程序可能被拒绝加入到使用过高的带宽的应用程序商店
 */

// This number is not official, as far as I know there is no officially documented bandwidth limit
//这个数字不是官方,据我所知没有正式记录带宽限制

extern unsigned long const ASIWWANBandwidthThrottleAmount;

#if NS_BLOCKS_AVAILABLE
typedef void (^ASIBasicBlock)(void);
typedef void (^ASIHeadersBlock)(NSDictionary *responseHeaders);
typedef void (^ASISizeBlock)(long long size);
typedef void (^ASIProgressBlock)(unsigned long long size, unsigned long long total);
typedef void (^ASIDataBlock)(NSData *data);
#endif

@interface ASIHTTPRequest : NSOperation <NSCopying> {
	
	// The url for this operation, should include GET params in the query string where appropriate
    // 这个操作的url,应该包括在查询字符串参数在适当的地方
	NSURL *url; 
	
	// Will always contain the original url used for making the request (the value of url can change when a request is redirected)
    // 总是包含原始url用于请求(url的值可以改变当请求重定向)
	NSURL *originalURL;
	
	// Temporarily stores the url we are about to redirect to. Will be nil again when we do redirect
    // 暂时存储url。将零再次当我们做重定向
    // 暂时我们将重定向到存储url。将零再次当我们做重定向
	NSURL *redirectURL;

	// The delegate - will be notified of various changes in state via the
    //各种变化的代表——将被通知通过状态
    
    //ASIHTTPRequestDelegate protocol
    //协议
	id <ASIHTTPRequestDelegate> delegate;
	
	// Another delegate that is also notified of request status changes and progress updates
    //另一个代表,也请求状态变化和进步更新的通知
    
	// Generally, you won't use this directly, but ASINetworkQueue sets itself as the queue so it can proxy updates to its own delegates
    //一般来说,你不会直接使用这个,但是ASINetworkQueue集本身的队列,这样就可以代理更新自己的代表
    
	// NOTE: WILL BE RETAINED BY THE REQUEST
    // 注:由请求将被保留
	id <ASIHTTPRequestDelegate, ASIProgressDelegate> queue;
	
	// HTTP method to use (eg: GET / POST / PUT / DELETE / HEAD etc). Defaults to GET
    // 使用HTTP方法(如:GET / POST / PUT /删除/头等)。默认为得到
	NSString *requestMethod;
	
	// Request body - only used when the whole body is stored in memory (shouldStreamPostDataFromDisk is false)
    //请求主体——只有当整个身体都存储在内存(应该流Post数据从磁盘是假的)
	NSMutableData *postBody;
	
	// gzipped request body used when shouldCompressRequestBody is YES
    // gzi页请求主体时使用压缩请求主体应该是肯定的
	NSData *compressedPostBody;
	
	// When true, post body will be streamed from a file on disk, rather than loaded into memory at once (useful for large uploads)
	// Automatically set to true in ASIFormDataRequests when using setFile:forKey:
    //　　真时,身体会从磁盘上的文件流,而不是一次性加载到内存(用于大型上传)
    //　　自动设置为true ASIFormDataRequests当使用setFile:forKey:
	BOOL shouldStreamPostDataFromDisk;
	
	// Path to file used to store post body (when shouldStreamPostDataFromDisk is true)
    //路径文件用于存储后的身体(当shouldStreamPostDataFromDisk是真实的)
	// You can set this yourself - useful if you want to PUT a file from local disk
    //你可以设置这个你自己——有用如果你想将一个文件从本地磁盘
	NSString *postBodyFilePath;
	
	// Path to a temporary file used to store a deflated post body (when shouldCompressPostBody is YES)
    //通往一个临时文件用于存储一个泄气后的身体(当shouldCompressPostBody是的)
	NSString *compressedPostBodyFilePath;
	
	// Set to true when ASIHTTPRequest automatically created a temporary file containing the request body (when true, the file at postBodyFilePath will be deleted at the end of the request)
    //设置为true时ASIHTTPRequest自动创建一个临时文件中包含请求主体(postBodyFilePath真实时,文件将被删除的请求)
	BOOL didCreateTemporaryPostDataFile;
	
	// Used when writing to the post body when shouldStreamPostDataFromDisk is true (via appendPostData: or appendPostDataFromFile:)
    //写后的身体当shouldStreamPostDataFromDisk时使用是正确的(通过appendPostData:或者appendPostDataFromFile:)
	NSOutputStream *postBodyWriteStream;
	
	// Used for reading from the post body when sending the request
    // 用于发送请求时从身体后阅读
	NSInputStream *postBodyReadStream;
	
	// Dictionary for custom HTTP request headers
    // 词典自定义HTTP请求头
	NSMutableDictionary *requestHeaders;
	
	// Set to YES when the request header dictionary has been populated, used to prevent this happening more than once
    //设置为YES,当请求头字典被填充,用来防止这种情况不止一次
	BOOL haveBuiltRequestHeaders;
	
	// Will be populated with HTTP response headers from the server
    // 从服务器将使用HTTP响应头部填充
	NSDictionary *responseHeaders;
	
	// Can be used to manually insert cookie headers to a request, but it's more likely that sessionCookies will do this for you
    //可以用来手动插入饼干头请求,但它更可能sessionCookies会这样做吗
	NSMutableArray *requestCookies;
	
	// Will be populated with cookies
    // 将填充Cookie
	NSArray *responseCookies;
	
	// If use useCookiePersistence is true, network requests will present valid cookies from previous requests
    // 如果使用使用Cookie持久性是真的,网络请求将有效的饼干从先前的请求
	BOOL useCookiePersistence;
	
	// If useKeychainPersistence is true, network requests will attempt to read credentials from the keychain, and will save them in the keychain when they are successfully presented
    //如果使用的钥匙链上的持久性是真的,网络请求将尝试阅读凭证从钥匙链,并将它们保存在钥匙链当他们成功了
	BOOL useKeychainPersistence;
	
	// If useSessionPersistence is true, network requests will save credentials and reuse for the duration of the session (until clearSession is called)
    //如果使用会话持久性是真的,网络请求将保存凭证和重用会话期间(直到清晰的会话被称为)
	BOOL useSessionPersistence;
	
	// If allowCompressedResponse is true, requests will inform the server they can accept compressed data, and will automatically decompress gzipped responses. Default is true.
    //如果允许压缩响应是真的,会通知服务器的请求他们可以接受压缩数据,并将自动解压gzip响应。默认是正确的。
	BOOL allowCompressedResponse;
	
	// If shouldCompressRequestBody is true, the request body will be gzipped. Default is false.
    //如果压缩请求主体应该是真的,将gzip请求主体。默认是假的。
    
	// You will probably need to enable this feature on your webserver to make this work. Tested with apache only.
    //你可能会需要你的网络服务器上启用这个特性使这项工作。测试与apache。
	BOOL shouldCompressRequestBody;
	
	// When downloadDestinationPath is set, the result of this request will be downloaded to the file at this location
    //当下载目的地路径设置,此请求的结果将下载到的文件在这个位置
	// If downloadDestinationPath is not set, download data will be stored in memory
    //如果没有设置下载目标路径,下载数据将存储在内存中
	NSString *downloadDestinationPath;
	
	// The location that files will be downloaded to. Once a download is complete, files will be decompressed (if necessary) and moved to downloadDestinationPath
    //将下载文件的位置。一旦下载完成,文件将解压缩(如果需要)和移动路径下载的目的地
	NSString *temporaryFileDownloadPath;
	
	// If the response is gzipped and shouldWaitToInflateCompressedResponses is NO, a file will be created at this path containing the inflated response as it comes in
    //如果响应是gzip,应该等待ToInflate压缩的回答是否定的,一个文件将被创建在这个路径包含的响应,因为它出现的原因
	NSString *temporaryUncompressedDataDownloadPath;
	
	// Used for writing data to a file when downloadDestinationPath is set
    //用于将数据写入一个文件下载时目的地路径设置
	NSOutputStream *fileDownloadOutputStream;
	
	NSOutputStream *inflatedFileDownloadOutputStream;
	
	// When the request fails or completes successfully, complete will be true
    //请求失败或成功完成时,完成将是正确的
	BOOL complete;
	
    // external "finished" indicator, subject of KVO notifications; updates after 'complete'
    //外部“完成”指标,KVO通知的主题;“完成”后更新
    BOOL finished;
    
    // True if our 'cancel' selector has been called
    //如果我们选择器被称为“取消”
    BOOL cancelled;
    
	// If an error occurs, error will contain an NSError
    // 如果出现错误,错误将包含一个NSError
    
	// If error code is = ASIConnectionFailureErrorType (1, Connection failure occurred) - inspect [[error userInfo] objectForKey:NSUnderlyingErrorKey] for more information
    //如果错误代码= ASIConnection失败错误类型(1、连接失败发生)——检查[[错误用户信息]objectForKey NSUnderlyingErrorKey):获得更多信息
	NSError *error;
	
	// Username and password used for authentication
    // 用于身份验证的用户名和密码
	NSString *username;
	NSString *password;
	
	// User-Agent for this request
    //用户代理的这个请求
	NSString *userAgentString;
	
	// Domain used for NTLM authentication
    // 域用于NTLM身份验证
	NSString *domain;
	
	// Username and password used for proxy authentication
    // 用于代理身份验证的用户名和密码
	NSString *proxyUsername;
	NSString *proxyPassword;
	
	// Domain used for NTLM proxy authentication
    // 域用于NTLM代理身份验证
	NSString *proxyDomain;
	
	// Delegate for displaying upload progress (usually an NSProgressIndicator, but you can supply a different object and handle this yourself)
    //代表显示上传进度(通常一个NS ProgressIndicator,但是你可以提供一个不同的对象和处理这个问题你自己)
	id <ASIProgressDelegate> uploadProgressDelegate;
	
	// Delegate for displaying download progress (usually an NSProgressIndicator, but you can supply a different object and handle this yourself)
    //代表显示下载进度(通常一个NSProgressIndicator,但是你可以提供一个不同的对象和处理)
	id <ASIProgressDelegate> downloadProgressDelegate;
	
	// Whether we've seen the headers of the response yet
    // 是否我们已经看到响应的头
    BOOL haveExaminedHeaders;
	
	// Data we receive will be stored here. Data may be compressed unless allowCompressedResponse is false - you should use [request responseData] instead in most cases
    //我们收到的数据将存储在这里。数据可能被压缩,除非允许压缩响应是假的——你应该使用[请求responseData]中而不是在大多数情况下
	NSMutableData *rawResponseData;
	
	// Used for sending and receiving data
    //用于发送和接收数据
    CFHTTPMessageRef request;	
	NSInputStream *readStream;
	
	// Used for authentication
    // 用于身份验证
    CFHTTPAuthenticationRef requestAuthentication; 
	NSDictionary *requestCredentials;
	
	// Used during NTLM authentication
    // 期间使用NTLM身份验证
	int authenticationRetryCount;
	
	// Authentication scheme (Basic, Digest, NTLM)
    // 身份验证方案(基本消化,NTLM)
    
	// If you are using Basic authentication and want to force ASIHTTPRequest to send an authorization header without waiting for a 401, you must set this to (NSString *)kCFHTTPAuthenticationSchemeBasic
    //如果您正在使用基本身份验证,想强迫ASIHTTPRequest发送授权头没有等待401年,你必须设置这个kCFHTTPAuthenticationSchemeBasic(NSString *)
	NSString *authenticationScheme;
	
	// Realm for authentication when credentials are required
    // 领域时的身份验证凭证
	NSString *authenticationRealm;
	
	// When YES, ASIHTTPRequest will present a dialog allowing users to enter credentials when no-matching credentials were found for a server that requires authentication
    //当是的,ASIHTTPRequest将出现一个对话框允许用户输入凭证时发现没有一个相匹配的凭证的服务器需要身份验证
    
	// The dialog will not be shown if your delegate responds to authenticationNeededForRequest:
    //对话框将不会显示如果你代表响应authenticationNeededForRequest:
    
	// Default is NO.
    //默认是否定的。
	BOOL shouldPresentAuthenticationDialog;
	
	// When YES, ASIHTTPRequest will present a dialog allowing users to enter credentials when no-matching credentials were found for a proxy server that requires authentication
    //当是的,ASIHTTPRequest将出现一个对话框允许用户输入凭证时发现没有一个相匹配的凭证需要认证的代理服务器
    
	// The dialog will not be shown if your delegate responds to proxyAuthenticationNeededForRequest:
    //对话框将不会显示如果你代表响应proxyAuthenticationNeededForRequest:
    
	// Default is YES (basically, because most people won't want the hassle of adding support for authenticating proxies to their apps)
    //默认是肯定的(基本上,因为大多数人不希望麻烦支持身份验证代理添加到他们的应用程序)
	BOOL shouldPresentProxyAuthenticationDialog;	
	
	// Used for proxy authentication
    // 用于代理身份验证
    CFHTTPAuthenticationRef proxyAuthentication; 
	NSDictionary *proxyCredentials;
	
	// Used during authentication with an NTLM proxy
    // 在与一个NTLM身份验证代理使用
	int proxyAuthenticationRetryCount;
	
	// Authentication scheme for the proxy (Basic, Digest, NTLM)
    // 代理身份验证方案(基本消化,NTLM)
	NSString *proxyAuthenticationScheme;	
	
	// Realm for proxy authentication when credentials are required
    // 领域的代理身份验证凭证时是必需的
	NSString *proxyAuthenticationRealm;
	
	// HTTP status code, eg: 200 = OK, 404 = Not found etc
    // HTTP状态代码,例如:200 =好吧,404 =没有发现等
	int responseStatusCode;
	
	// Description of the HTTP status code
    // 描述的HTTP状态代码
	NSString *responseStatusMessage;
	
	// Size of the response
    // 响应的大小
	unsigned long long contentLength;
	
	// Size of the partially downloaded content
    // 部分下载内容的大小
	unsigned long long partialDownloadSize;
	
	// Size of the POST payload
    // 大小的负载
	unsigned long long postLength;	
	
	// The total amount of downloaded data
    // 下载数据的总量
	unsigned long long totalBytesRead;
	
	// The total amount of uploaded data
    // 上传数据的总量
	unsigned long long totalBytesSent;
	
	// Last amount of data read (used for incrementing progress)
    // 最后读取的数据量(用于递增的进步)
	unsigned long long lastBytesRead;
	
	// Last amount of data sent (used for incrementing progress)
    // 最后一次发送的数据量(用于递增的进步)
	unsigned long long lastBytesSent;
	
	// This lock prevents the operation from being cancelled at an inopportune moment
    // 这把锁可以防止操作被取消了在一个不恰当的时刻
	NSRecursiveLock *cancelledLock;
	
	// Called on the delegate (if implemented) when the request starts. Default is requestStarted:
    //呼吁代表请求启动时(如果实现)。默认是requestStarted:
	SEL didStartSelector;
	
	// Called on the delegate (if implemented) when the request receives response headers. Default is request:didReceiveResponseHeaders:
    //呼吁代表(如果实现)当请求接收响应标头。默认是请求:didReceiveResponseHeaders:
	SEL didReceiveResponseHeadersSelector;

	// Called on the delegate (if implemented) when the request receives a Location header and shouldRedirect is YES
    //呼吁代表(如果实现)当请求接收头位置和shouldRedirect是肯定的
    
	// The delegate can then change the url if needed, and can restart the request by calling [request redirectToURL:], or simply cancel it
    //代表可以改变url如果需要,并且可以重新启动请求通过调用请求redirectToURL:,或者干脆取消它
	SEL willRedirectSelector;

	// Called on the delegate (if implemented) when the request completes successfully. Default is requestFinished:
    //呼吁代表请求成功完成时(如果实现)。默认是requestFinished:
	SEL didFinishSelector;
	
	// Called on the delegate (if implemented) when the request fails. Default is requestFailed:
    //呼吁代表请求失败时(如果实现)。默认是requestFailed:
	SEL didFailSelector;
	
	// Called on the delegate (if implemented) when the request receives data. Default is request:didReceiveData:
    //呼吁代表请求接收数据时(如果实现)。默认是要求:didReceiveData:
    
	// If you set this and implement the method in your delegate, you must handle the data yourself - ASIHTTPRequest will not populate responseData or write the data to downloadDestinationPath
    //如果你将这个代表和实现方法,你必须处理数据——ASIHTTPRequest不会填充downloadDestinationPath responseData或写数据中
	SEL didReceiveDataSelector;
	
	// Used for recording when something last happened during the request, we will compare this value with the current date to time out requests when appropriate
    //用来记录去年发生在请求时,我们将比较此值与当前日期时间请求在适当的时候
	NSDate *lastActivityTime;
	
	// Number of seconds to wait before timing out - default is 10
    // 超时之前要等待的秒数,默认是10
	NSTimeInterval timeOutSeconds;
	
	// Will be YES when a HEAD request will handle the content-length before this request starts
    //将内容长度是的HEAD请求时将处理该请求开始前
	BOOL shouldResetUploadProgress;
	BOOL shouldResetDownloadProgress;
	
	// Used by HEAD requests when showAccurateProgress is YES to preset the content-length for this request
    //使用HEAD请求当showAccurateProgress是的预设内容长度为这个请求
	ASIHTTPRequest *mainRequest;
	
	// When NO, this request will only update the progress indicator when it completes
    //当没有,这个请求只会更新进度完成
    
	// When YES, this request will update the progress indicator according to how much data it has received so far
    //当是的,这个请求将会更新进度指示器显示多少数据到目前为止已收到
    
	// The default for requests is YES
    //默认的请求是肯定的
    
	// Also see the comments in ASINetworkQueue.h
    // 也看到ASINetworkQueue.h中的注释
	BOOL showAccurateProgress;
	
	// Used to ensure the progress indicator is only incremented once when showAccurateProgress = NO
    //用于确保进度指示器只增加一次当showAccurateProgress = NO
	BOOL updatedProgress;
	
	// Prevents the body of the post being built more than once (largely for subclasses)
    //防止文章的主体建不止一次(主要为子类)
	BOOL haveBuiltPostBody;
	
	// Used internally, may reflect the size of the internal buffer used by CFNetwork
    //在内部使用,可能反映了CFNetwork所使用的内部缓冲区的大小
    
	// POST / PUT operations with body sizes greater than uploadBufferSize will not timeout unless more than uploadBufferSize bytes have been sent
    //与身体大小大于uploadBufferSize POST或PUT操作不会超时,除非超过uploadBufferSize字节被发送
    
	// Likely to be 32KB on iPhone 3.0, 128KB on Mac OS X Leopard and iPhone 2.2.x
    // 可能是32 kb iPhone 3.0,128 kb在Mac OS X Leopard和iPhone 2.2.x
	unsigned long long uploadBufferSize;
	
	// Text encoding for responses that do not send a Content-Type with a charset value. Defaults to NSISOLatin1StringEncoding
    
    //文本编码的响应不发送一个内容类型和字符集的价值。默认为NSISOLatin1StringEncoding
	NSStringEncoding defaultResponseEncoding;
	
	// The text encoding of the response, will be defaultResponseEncoding if the server didn't specify. Can't be set.
    //响应的文本编码,将defaultResponseEncoding如果服务器没有指定。不能设置。
	NSStringEncoding responseEncoding;
	
	// Tells ASIHTTPRequest not to delete partial downloads, and allows it to use an existing file to resume a download. Defaults to NO.
    //告诉ASIHTTPRequest不要删除部分下载,并允许它使用一个现存的文件恢复下载。默认为没有。
	BOOL allowResumeForFileDownloads;
	
	// Custom user information associated with the request (not sent to the server)
    //定制与请求相关联的用户信息(不发送到服务器)
	NSDictionary *userInfo;
	NSInteger tag;
	
	// Use HTTP 1.0 rather than 1.1 (defaults to false)
    //使用HTTP 1.0而不是1.1(默认值为false)
	BOOL useHTTPVersionOne;
	
	// When YES, requests will automatically redirect when they get a HTTP 30x header (defaults to YES)
    //使用HTTP 1.0而不是1.1(默认值为false)
	BOOL shouldRedirect;
	
	// Used internally to tell the main loop we need to stop and retry with a new url
    //在内部使用,告诉主循环,我们需要停止与一个新的url并重试
	BOOL needsRedirect;
	
	// Incremented every time this request redirects. When it reaches 5, we give up
    //增加每次这个请求重定向。当它到达5,我们放弃
	int redirectCount;
	
	// When NO, requests will not check the secure certificate is valid (use for self-signed certificates during development, DO NOT USE IN PRODUCTION) Default is YES
    //当没有,请求将不会检查安全证书是有效的(在开发过程中使用自签名证书,不用于生产)默认是肯定的
	BOOL validatesSecureCertificate;
    
    // If not nil and the URL scheme is https, CFNetwork configured to supply a client certificate
    //如果不是零和https URL方案,CFNetwork配置为提供一个客户端证书
    SecIdentityRef clientCertificateIdentity;
	NSArray *clientCertificates;
	
	// Details on the proxy to use - you could set these yourself, but it's probably best to let ASIHTTPRequest detect the system proxy settings
    //代理使用的细节,您可以设置这些自己,但最好让ASIHTTPRequest检测系统代理设置
	NSString *proxyHost;
	int proxyPort;
	
	// ASIHTTPRequest will assume kCFProxyTypeHTTP if the proxy type could not be automatically determined
    //ASIHTTPRequest假设kCFProxyTypeHTTP如果代理类型不能自动确定
    
	// Set to kCFProxyTypeSOCKS if you are manually configuring a SOCKS proxy
    //设置为kCFProxyTypeSOCKS如果你手动配置SOCKS代理
	NSString *proxyType;

	// URL for a PAC (Proxy Auto Configuration) file. If you want to set this yourself, it's probably best if you use a local file
    //URL PAC(代理自动配置)文件。如果你想要将这个自己,最好如果你使用一个本地文件
	NSURL *PACurl;
	
	// See ASIAuthenticationState values above. 0 == default == No authentication needed yet
    //参见上面的ASIAuthenticationState值。0 = =默认= =不需要身份验证
	ASIAuthenticationState authenticationNeeded;
	
	// When YES, ASIHTTPRequests will present credentials from the session store for requests to the same server before being asked for them
	// This avoids an extra round trip for requests after authentication has succeeded, which is much for efficient for authenticated requests with large bodies, or on slower connections
	// Set to NO to only present credentials when explicitly asked for them
	// This only affects credentials stored in the session cache when useSessionPersistence is YES. Credentials from the keychain are never presented unless the server asks for them
	// Default is YES
	// For requests using Basic authentication, set authenticationScheme to (NSString *)kCFHTTPAuthenticationSchemeBasic, and credentials can be sent on the very first request when shouldPresentCredentialsBeforeChallenge is YES
    
    //当是的,ASIHTTPRequests将从会话存储凭证请求相同的服务器被要求之前
    //这避免了额外的往返请求身份验证成功之后,这是有效的身份验证请求与大型机构,或在较慢的连接
    //设置为没有,只有当明确要求他们递交国书
    //这只会影响凭证存储在会话缓存useSessionPersistence是肯定的。凭证从钥匙链从不提出,除非服务器要求他们
    //默认是肯定的
    //请求使用基本身份验证,设置authenticationScheme(NSString *)kCFHTTPAuthenticationSchemeBasic,凭证可以发送第一个请求时shouldPresentCredentialsBeforeChallenge是肯定的
	BOOL shouldPresentCredentialsBeforeChallenge;
	
	// YES when the request hasn't finished yet. Will still be YES even if the request isn't doing anything (eg it's waiting for delegate authentication). READ-ONLY
    //是的,当请求尚未完成。仍将是的即使请求不做任何事情(如等待代表身份验证)。只读
	BOOL inProgress;
	
	// Used internally to track whether the stream is scheduled on the run loop or not
	// Bandwidth throttling can unschedule the stream to slow things down while a request is in progress
    //内部使用跟踪流是否计划在循环运行
    //带宽节流可以unschedule流慢下来的请求是在进步
	BOOL readStreamIsScheduled;
	
	// Set to allow a request to automatically retry itself on timeout
	// Default is zero - timeout will stop the request
    //设置为允许请求超时自动重试本身
    //默认为零,超时将停止请求
	int numberOfTimesToRetryOnTimeout;

	// The number of times this request has retried (when numberOfTimesToRetryOnTimeout > 0)
    // 这个请求重试的次数(当numberOfTimesToRetryOnTimeout > 0)
	int retryCount;

	// Temporarily set to YES when a closed connection forces a retry (internally, this stops ASIHTTPRequest cleaning up a temporary post body)
    
    //暂时设置为YES当关闭连接部队重试(在内部,这将停止ASIHTTPRequest清理临时post的身体)
	BOOL willRetryRequest;

	// When YES, requests will keep the connection to the server alive for a while to allow subsequent requests to re-use it for a substantial speed-boost
    //当是的,请求将保持连接到服务器的活跃一段时间允许后续请求重用大量速度的提升
    
	// Persistent connections will not be used if the server explicitly closes the connection
    //持久连接将不会使用如果服务器显式地关闭连接
	// Default is YES
	BOOL shouldAttemptPersistentConnection;

	// Number of seconds to keep an inactive persistent connection open on the client side
	// Default is 60
	// If we get a keep-alive header, this is this value is replaced with how long the server told us to keep the connection around
	// A future date is created from this and used for expiring the connection, this is stored in connectionInfo's expires value
    
    //秒数来保持一个不活动的持久连接打开客户端
    //默认是60
    //如果我们得到一个点火电极头,这是这个值替换服务器多长时间告诉我们保持联系
    //创建一个将来的日期,用于连接到期,这是存储在connectionInfo到期值
	NSTimeInterval persistentConnectionTimeoutSeconds;
	
	// Set to yes when an appropriate keep-alive header is found
    // 设置为yes,当找到一个合适的点火电极头
	BOOL connectionCanBeReused;
	
	// Stores information about the persistent connection that is currently in use.
	// It may contain:
	// * The id we set for a particular connection, incremented every time we want to specify that we need a new connection
	// * The date that connection should expire
	// * A host, port and scheme for the connection. These are used to determine whether that connection can be reused by a subsequent request (all must match the new request)
    //*存储的信息目前正在使用的持久连接。
    //*它可能包含:
    //*的id设置为一个特定的连接,增加每次我们希望指定,我们需要一个新的连接
    //*,连接应该到期的日期
    //*主机、端口和连接方案。这些都是用来确定连接可以重用的后续请求(必须匹配所有新的请求)
    
	// * An id for the request that is currently using the connection. This is used for determining if a connection is available or not (we store a number rather than a reference to the request so we don't need to hang onto a request until the connection expires)
	// * A reference to the stream that is currently using the connection. This is necessary because we need to keep the old stream open until we've opened a new one.
	//   The stream will be closed + released either when another request comes to use the connection, or when the timer fires to tell the connection to expire
    // *一个id为请求,目前使用连接。这是用于确定连接是否可用(我们商店而不是请求的引用,所以我们不需要依附一个请求,直到连接到期)
    //*流,目前使用的引用连接。这是必要的,因为我们需要保持老流开到我们开了一个新的。
    //流将关闭+发布另一个请求时使用的连接,或当定时器触发告诉连接过期
	NSMutableDictionary *connectionInfo;
	
	// When set to YES, 301 and 302 automatic redirects will use the original method and and body, according to the HTTP 1.1 standard
	// Default is NO (to follow the behaviour of most browsers)
    //设置为YES,301年和302年自动重定向将使用原来的方法和和身体,根据HTTP 1.1标准
    //默认是没有(遵循大多数浏览器的行为)
	BOOL shouldUseRFC2616RedirectBehaviour;
	
	// Used internally to record when a request has finished downloading data
    // 内部使用记录,当一个请求完成下载数据
	BOOL downloadComplete;
	
	// An ID that uniquely identifies this request - primarily used for debugging persistent connections
    //一个ID,惟一地标识此请求,主要用于调试持久连接
	NSNumber *requestID;
	
	// Will be ASIHTTPRequestRunLoopMode for synchronous requests, NSDefaultRunLoopMode for all other requests
    //将ASIHTTPRequestRunLoopMode同步请求,NSDefaultRunLoopMode所有其他请求吗
	NSString *runLoopMode;
	
	// This timer checks up on the request every 0.25 seconds, and updates progress
    // 这个计时器检查请求每0.25秒,并更新进展
	NSTimer *statusTimer;
	
	// The download cache that will be used for this request (use [ASIHTTPRequest setDefaultCache:cache] to configure a default cache
    //下载缓存,将用于这个请求(使用[ASIHTTPRequest setDefaultCache:缓存)来配置一个默认的缓存
	id <ASICacheDelegate> downloadCache;
	
	// The cache policy that will be used for this request - See ASICacheDelegate.h for possible values
    //将用于这个请求的缓存策略——看到ASICacheDelegate。h为可能的值
	ASICachePolicy cachePolicy;
	
	//缓存存储策略,将用于这个请求——看到ASICacheDelegate。h为可能的值
	ASICacheStoragePolicy cacheStoragePolicy;
	
	// Will be true when the response was pulled from the cache rather than downloaded
    //将真实的反应时从缓存而不是下载
	BOOL didUseCachedResponse;

	// Set secondsToCache to use a custom time interval for expiring the response when it is stored in a cache
    //secondsToCache设置为使用一个自定义的时间间隔到期时响应存储在缓存中
	NSTimeInterval secondsToCache;

	#if TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_4_0
	BOOL shouldContinueWhenAppEntersBackground;
	UIBackgroundTaskIdentifier backgroundTask;
	#endif
	
	// When downloading a gzipped response, the request will use this helper object to inflate the response
    //请求下载gzip响应时,将使用这个helper对象膨胀响应
	ASIDataDecompressor *dataDecompressor;
	
	// Controls how responses with a gzipped encoding are inflated (decompressed)
	// When set to YES (This is the default):
	// * gzipped responses for requests without a downloadDestinationPath will be inflated only when [request responseData] / [request responseString] is called
	// * gzipped responses for requests with a downloadDestinationPath set will be inflated only when the request completes
	
    //控制如何使用gzip编码的响应(解压缩)
    //当设置为YES(这是默认的):
    // * gzip响应请求没有downloadDestinationPath将膨胀只有当[请求responseData]中/[请求responseString]
    // * gzip反应与一组downloadDestinationPath请求将膨胀只有在请求完成
    
	// When set to NO
	// All requests will inflate the response as it comes in
	// * If the request has no downloadDestinationPath set, the raw (compressed) response is discarded and rawResponseData will contain the decompressed response
	// * If the request has a downloadDestinationPath, the raw response will be stored in temporaryFileDownloadPath as normal, the inflated response will be stored in temporaryUncompressedDataDownloadPath
	//   Once the request completes successfully, the contents of temporaryUncompressedDataDownloadPath are moved into downloadDestinationPath
    //当设置为NO
    //所有请求将膨胀的响应,因为它出现的原因
    // *如果请求没有downloadDestinationPath集,原始(压缩)响应被丢弃和rawResponseData将包含压缩响应
    // *如果请求downloadDestinationPath,原始的响应将存储在temporaryFileDownloadPath正常,膨胀的响应将存储在temporaryUncompressedDataDownloadPath
    //请求成功完成后,进入downloadDestinationPath temporaryUncompressedDataDownloadPath的内容
    
	
	// Setting this to NO may be especially useful for users using ASIHTTPRequest in conjunction with a streaming parser, as it will allow partial gzipped responses to be inflated and passed on to the parser while the request is still running
    //设置这个不可能特别适合用户使用ASIHTTPRequest结合流解析器,因为它将允许部分gzip反应膨胀和传递给解析器而请求仍在运行
	BOOL shouldWaitToInflateCompressedResponses;

	// Will be YES if this is a request created behind the scenes to download a PAC file - these requests do not attempt to configure their own proxies
    //将是的如果这是创建一个请求在后台下载PAC文件——这些请求不要试图配置自己的代理
	BOOL isPACFileRequest;

	// Used for downloading PAC files from http / https webservers
    //用于从http / https的网路下载PAC文件
	ASIHTTPRequest *PACFileRequest;

	// Used for asynchronously reading PAC files from file:// URLs
    //用于异步读取PAC文件从文件:/ / url
	NSInputStream *PACFileReadStream;

	// Used for storing PAC data from file URLs as it is downloaded
    //用于存储PAC url是下载的数据文件
	NSMutableData *PACFileData;

	// Set to YES in startSynchronous. Currently used by proxy detection to download PAC files synchronously when appropriate
    //在startSynchronous设置为YES。目前所使用的代理检测同步下载PAC文件在适当的时候
	BOOL isSynchronous;

	#if NS_BLOCKS_AVAILABLE
	//block to execute when request starts
    //块请求启动时执行
	ASIBasicBlock startedBlock;

	//block to execute when headers are received
    //当收到标题块执行
	ASIHeadersBlock headersReceivedBlock;

	//block to execute when request completes successfully
    //块请求成功完成时执行
	ASIBasicBlock completionBlock;

	//block to execute when request fails
    //请求失败时执行
	ASIBasicBlock failureBlock;

	//block for when bytes are received
    //当收到字节
	ASIProgressBlock bytesReceivedBlock;

	//block for when bytes are sent
    //当发送字节块
	ASIProgressBlock bytesSentBlock;

	//block for when download size is incremented
    //块当下载大小递增
	ASISizeBlock downloadSizeIncrementedBlock;

	//block for when upload size is incremented
    //块当上传大小递增
	ASISizeBlock uploadSizeIncrementedBlock;

	//block for handling raw bytes received
    //块来处理原始字节收到
	ASIDataBlock dataReceivedBlock;

	//block for handling authentication
    //块来处理身份验证
	ASIBasicBlock authenticationNeededBlock;

	//block for handling proxy authentication
    //块来处理代理身份验证
	ASIBasicBlock proxyAuthenticationNeededBlock;
	
    //block for handling redirections, if you want to
    //块处理重定向的,如果你想
    ASIBasicBlock requestRedirectedBlock;
	#endif
}

#pragma mark init / dealloc

// Should be an HTTP or HTTPS url, may include username and password if appropriate
// 应该是一个HTTP或HTTPS url,可能包括用户名和密码是否适当
- (id)initWithURL:(NSURL *)newURL;

// Convenience constructor
// 构造函数
+ (id)requestWithURL:(NSURL *)newURL;

+ (id)requestWithURL:(NSURL *)newURL usingCache:(id <ASICacheDelegate>)cache;
+ (id)requestWithURL:(NSURL *)newURL usingCache:(id <ASICacheDelegate>)cache andCachePolicy:(ASICachePolicy)policy;

#if NS_BLOCKS_AVAILABLE
- (void)setStartedBlock:(ASIBasicBlock)aStartedBlock;
- (void)setHeadersReceivedBlock:(ASIHeadersBlock)aReceivedBlock;
- (void)setCompletionBlock:(ASIBasicBlock)aCompletionBlock;
- (void)setFailedBlock:(ASIBasicBlock)aFailedBlock;
- (void)setBytesReceivedBlock:(ASIProgressBlock)aBytesReceivedBlock;
- (void)setBytesSentBlock:(ASIProgressBlock)aBytesSentBlock;
- (void)setDownloadSizeIncrementedBlock:(ASISizeBlock) aDownloadSizeIncrementedBlock;
- (void)setUploadSizeIncrementedBlock:(ASISizeBlock) anUploadSizeIncrementedBlock;
- (void)setDataReceivedBlock:(ASIDataBlock)aReceivedBlock;
- (void)setAuthenticationNeededBlock:(ASIBasicBlock)anAuthenticationBlock;
- (void)setProxyAuthenticationNeededBlock:(ASIBasicBlock)aProxyAuthenticationBlock;
- (void)setRequestRedirectedBlock:(ASIBasicBlock)aRedirectBlock;
#endif

#pragma mark setup request

// Add a custom header to the request
//自定义标题添加到请求
- (void)addRequestHeader:(NSString *)header value:(NSString *)value;

// Called during buildRequestHeaders and after a redirect to create a cookie header from request cookies and the global store
//称为buildRequestHeaders期间,从请求重定向到创建一个饼干头后饼干和全球存储
- (void)applyCookieHeader;

// Populate the request headers dictionary. Called before a request is started, or by a HEAD request that needs to borrow them
//填充请求头字典。称为请求开始之前,或由HEAD请求,需要借用
- (void)buildRequestHeaders;

// Used to apply authorization header to a request before it is sent (when shouldPresentCredentialsBeforeChallenge is YES)
//用于授权头适用于发送请求之前(当shouldPresentCredentialsBeforeChallenge是的)
- (void)applyAuthorizationHeader;


// Create the post body
// 创建后的身体
- (void)buildPostBody;

// Called to add data to the post body. Will append to postBody when shouldStreamPostDataFromDisk is false, or write to postBodyWriteStream when true
//将数据添加到帖子的身体。将附加postBody shouldStreamPostDataFromDisk假时,或写postBodyWriteStream时真的吗
- (void)appendPostData:(NSData *)data;
- (void)appendPostDataFromFile:(NSString *)file;

#pragma mark get information about this request

// Returns the contents of the result as an NSString (not appropriate for binary data - used responseData instead)
//返回的内容结果作为NSString(不适合二进制数据- responseData)中使用
- (NSString *)responseString;

// Response data, automatically uncompressed where appropriate
//在适当的地方响应数据,自动压缩
- (NSData *)responseData;

// Returns true if the response was gzip compressed
//返回true,如果反应是gzip压缩
- (BOOL)isResponseCompressed;

#pragma mark running a request


// Run a request synchronously, and return control when the request completes or fails
// 运行一个同步请求,并返回控制当请求完成或失败
- (void)startSynchronous;

// Run request in the background
// 请求在后台运行
- (void)startAsynchronous;

// Clears all delegates and blocks, then cancels the request
// 清除所有代表和街区,然后取消请求
- (void)clearDelegatesAndCancel;

#pragma mark HEAD request

// Used by ASINetworkQueue to create a HEAD request appropriate for this request with the same headers (though you can use it yourself)
//ASINetworkQueue用来创建一个HEAD请求适合这个请求相同的标题(尽管您可以使用它自己)
- (ASIHTTPRequest *)HEADRequest;

#pragma mark upload/download progress

// Called approximately every 0.25 seconds to update the progress delegates
// 调用代表大约每0.25秒更新进展
- (void)updateProgressIndicators;

// Updates upload progress (notifies the queue and/or uploadProgressDelegate of this request)
//更新上传进度(通知队列和/或uploadProgressDelegate的请求)
- (void)updateUploadProgress;

// Updates download progress (notifies the queue and/or uploadProgressDelegate of this request)
//更新下载进度(通知队列和/或上载进度代表的请求)
- (void)updateDownloadProgress;

// Called when authorisation is needed, as we only find out we don't have permission to something when the upload is complete
//时调用授权是必要的,因为我们只发现我们没有权限上传完成后的东西
- (void)removeUploadProgressSoFar;

// Called when we get a content-length header and shouldResetDownloadProgress is true
// 当我们得到内容长度头,应该重新下载进度是真的
- (void)incrementDownloadSizeBy:(long long)length;

// Called when a request starts and shouldResetUploadProgress is true
//时调用请求的开始和shouldResetUploadProgress是真的

// Also called (with a negative length) to remove the size of the underlying buffer used for uploading
//也称为(负长度)去除潜在的缓冲区的大小用于上传
- (void)incrementUploadSizeBy:(long long)length;

// Helper method for interacting with progress indicators to abstract the details of different APIS (NSProgressIndicator and UIProgressView)
//助手方法与进展进行交互指标抽象不同的api的细节(NSProgressIndicator和UIProgressView)
+ (void)updateProgressIndicator:(id *)indicator withProgress:(unsigned long long)progress ofTotal:(unsigned long long)total;

// Helper method used for performing invocations on the main thread (used for progress)
//辅助方法用于在主线程上执行调用(用于进展)
+ (void)performSelector:(SEL)selector onTarget:(id *)target withObject:(id)object amount:(void *)amount callerToRetain:(id)caller;

#pragma mark talking to delegates

// Called when a request starts, lets the delegate know via didStartSelector
//开始时调用请求,让代表通过didStartSelector知道
- (void)requestStarted;

// Called when a request receives response headers, lets the delegate know via didReceiveResponseHeadersSelector
//时调用请求接收响应标头,让代表通过didReceiveResponseHeadersSelector知道
- (void)requestReceivedResponseHeaders:(NSDictionary *)newHeaders;

// Called when a request completes successfully, lets the delegate know via didFinishSelector
//请求成功完成时调用,让代表通过didFinishSelector知道
- (void)requestFinished;

// Called when a request fails, and lets the delegate know via didFailSelector
//请求失败时调用,让代表通过didFailSelector知道
- (void)failWithError:(NSError *)theError;

// Called to retry our request when our persistent connection is closed
// Returns YES if we haven't already retried, and connection will be restarted
// Otherwise, returns NO, and nothing will happen

/*叫重试我们的要求当我们持久连接关闭
 *返回是的如果我们没有已经重试,和连接将会重新启动
 *否则,返回没有,什么都不会发生
 */
- (BOOL)retryUsingNewConnection;

// Can be called by delegates from inside their willRedirectSelector implementations to restart the request with a new url
//可以从在他们称为代表willRedirectSelector实现重新启动和一个新的url请求吗
- (void)redirectToURL:(NSURL *)newURL;

#pragma mark parsing HTTP response headers

// Reads the response headers to find the content length, encoding, cookies for the session 
// Also initiates request redirection when shouldRedirect is true
// And works out if HTTP auth is required
//读取响应头找到内容长度,编码,会话cookie
//还发起请求重定向时shouldRedirect是真的
//如果需要HTTP身份验证和工作
- (void)readResponseHeaders;

// Attempts to set the correct encoding by looking at the Content-Type header, if this is one
//试图设置正确的编码通过观察content - type报头,如果这就是其中之一
- (void)parseStringEncodingFromHeaders;

+ (void)parseMimeType:(NSString **)mimeType andResponseEncoding:(NSStringEncoding *)stringEncoding fromContentType:(NSString *)contentType;

#pragma mark http authentication stuff

// Apply credentials to this request
//凭证适用于此请求
- (BOOL)applyCredentials:(NSDictionary *)newCredentials;
- (BOOL)applyProxyCredentials:(NSDictionary *)newCredentials;

// Attempt to obtain credentials for this request from the URL, username and password or keychain
//试图获得这个证书请求URL,用户名和密码或钥匙链
- (NSMutableDictionary *)findCredentials;
- (NSMutableDictionary *)findProxyCredentials;

// Unlock (unpause) the request thread so it can resume the request
// 解锁(unpause)请求线程,这样就可以恢复请求
// Should be called by delegates when they have populated the authentication information after an authentication challenge
//应由代表填充时称为身份验证信息经过身份验证的挑战
- (void)retryUsingSuppliedCredentials;

// Should be called by delegates when they wish to cancel authentication and stop
// 时应由代表他们希望取消认证和停止吗
- (void)cancelAuthentication;

// Apply authentication information and resume the request after an authentication challenge
//应用身份验证信息和简历后请求身份验证的挑战
- (void)attemptToApplyCredentialsAndResume;
- (void)attemptToApplyProxyCredentialsAndResume;

// Attempt to show the built-in authentication dialog, returns YES if credentials were supplied, NO if user cancelled dialog / dialog is disabled / running on main thread
// Currently only used on iPhone OS
//为了显示内置验证对话框,返回是的如果提供凭证,没有如果用户取消对话框对话框禁用/运行在主线程
//目前只在iPhone操作系统上使用
- (BOOL)showProxyAuthenticationDialog;
- (BOOL)showAuthenticationDialog;

// Construct a basic authentication header from the username and password supplied, and add it to the request headers
//构建一个基本身份验证头从提供的用户名和密码,并将其添加到请求头

// Used when shouldPresentCredentialsBeforeChallenge is YES
// 时使用shouldPresentCredentialsBeforeChallenge是肯定的
- (void)addBasicAuthenticationHeaderWithUsername:(NSString *)theUsername andPassword:(NSString *)thePassword;

#pragma mark stream status handlers

// CFnetwork event handlers
// CFnetwork事件处理程序
- (void)handleNetworkEvent:(CFStreamEventType)type;
- (void)handleBytesAvailable;
- (void)handleStreamComplete;
- (void)handleStreamError;

#pragma mark cleanup

// Cleans up and lets the queue know this operation is finished.
// Appears in this header for subclassing only, do not call this method from outside your request!
//清理并让队列知道这个操作完成。
//只出现在这个头子类化,不从外部调用这个方法你的请求!
- (void)markAsFinished;

// Cleans up temporary files. There's normally no reason to call these yourself, they are called automatically when a request completes or fails
//清理临时文件。这些事通常没有理由骂自己,他们被称为一个请求时自动完成或失败

// Clean up the temporary file used to store the downloaded data when it comes in (if downloadDestinationPath is set)
//清理临时文件用于存储下载的数据时(如果downloadDestinationPath设置)
- (BOOL)removeTemporaryDownloadFile;

// Clean up the temporary file used to store data that is inflated (decompressed) as it comes in
// 清理临时文件用于存储下载的数据时(如果downloadDestinationPath设置
- (BOOL)removeTemporaryUncompressedDownloadFile;

// Clean up the temporary file used to store the request body (when shouldStreamPostDataFromDisk is YES)
//清理临时文件用于存储请求主体(当shouldStreamPostDataFromDisk是的)
- (BOOL)removeTemporaryUploadFile;

// Clean up the temporary file used to store a deflated (compressed) request body when shouldStreamPostDataFromDisk is YES
//清理临时文件用于存储一个泄气(压缩)请求主体当shouldStreamPostDataFromDisk是肯定的
- (BOOL)removeTemporaryCompressedUploadFile;

// Remove a file on disk, returning NO and populating the passed error pointer if it fails
// 删除磁盘上的文件,返回没有和填充错误指针如果失败了
+ (BOOL)removeFileAtPath:(NSString *)path error:(NSError **)err;

#pragma mark persistent connections

// Get the ID of the connection this request used (only really useful in tests and debugging)
//得到这个请求使用的ID连接(唯一真正有用的测试和调试)
- (NSNumber *)connectionID;

// Called automatically when a request is started to clean up any persistent connections that have expired
//时,将自动调用请求开始清理任何已经过期的持久连接
+ (void)expirePersistentConnections;

#pragma mark default time out

+ (NSTimeInterval)defaultTimeOutSeconds;
+ (void)setDefaultTimeOutSeconds:(NSTimeInterval)newTimeOutSeconds;

#pragma mark client certificate

- (void)setClientCertificateIdentity:(SecIdentityRef)anIdentity;

#pragma mark session credentials

+ (NSMutableArray *)sessionProxyCredentialsStore;
+ (NSMutableArray *)sessionCredentialsStore;

+ (void)storeProxyAuthenticationCredentialsInSessionStore:(NSDictionary *)credentials;
+ (void)storeAuthenticationCredentialsInSessionStore:(NSDictionary *)credentials;

+ (void)removeProxyAuthenticationCredentialsFromSessionStore:(NSDictionary *)credentials;
+ (void)removeAuthenticationCredentialsFromSessionStore:(NSDictionary *)credentials;

- (NSDictionary *)findSessionProxyAuthenticationCredentials;
- (NSDictionary *)findSessionAuthenticationCredentials;

#pragma mark keychain storage

// Save credentials for this request to the keychain
// 保存凭证请求到钥匙链
- (void)saveCredentialsToKeychain:(NSDictionary *)newCredentials;

// Save credentials to the keychain
//证书保存到钥匙链
+ (void)saveCredentials:(NSURLCredential *)credentials forHost:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;
+ (void)saveCredentials:(NSURLCredential *)credentials forProxy:(NSString *)host port:(int)port realm:(NSString *)realm;

// Return credentials from the keychain
//返回凭证从钥匙链
+ (NSURLCredential *)savedCredentialsForHost:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;
+ (NSURLCredential *)savedCredentialsForProxy:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;

// Remove credentials from the keychain
// 删除凭证从钥匙链
+ (void)removeCredentialsForHost:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;
+ (void)removeCredentialsForProxy:(NSString *)host port:(int)port realm:(NSString *)realm;

// We keep track of any cookies we accept, so that we can remove them from the persistent store later
//我们跟踪任何饼干我们接受,所以,我们可以把它们从持久存储中删除
+ (void)setSessionCookies:(NSMutableArray *)newSessionCookies;
+ (NSMutableArray *)sessionCookies;

// Adds a cookie to our list of cookies we've accepted, checking first for an old version of the same cookie and removing that
//添加一个曲奇饼干列表我们已经接受,首先检查一个旧版本相同的饼干和删除
+ (void)addSessionCookie:(NSHTTPCookie *)newCookie;

// Dump all session data (authentication and cookies)
// 转储所有会话数据(身份验证和饼干)
+ (void)clearSession;

#pragma mark get user agent

// Will be used as a user agent if requests do not specify a custom user agent
// Is only used when you have specified a Bundle Display Name (CFDisplayBundleName) or Bundle Name (CFBundleName) in your plist
/*
 将被用作一个用户代理如果请求不指定一个自定义用户代理吗
 　　时只使用指定包显示名称(CFDisplayBundleName)或包名(CFBundleName)在你的搭档一起吗
 */
+ (NSString *)defaultUserAgentString;
+ (void)setDefaultUserAgentString:(NSString *)agent;

#pragma mark mime-type detection

// Return the mime type for a file
//返回文件的mime类型
+ (NSString *)mimeTypeForFileAtPath:(NSString *)path;

#pragma mark bandwidth measurement / throttling

// The maximum number of bytes ALL requests can send / receive in a second
// This is a rough figure. The actual amount used will be slightly more, this does not include HTTP headers
/*
 所有请求的最大字节数可以在第二次发送/接收
 这是一个粗略的图。实际使用的数量将会稍微,这并不包括HTTP头
 */
+ (unsigned long)maxBandwidthPerSecond;
+ (void)setMaxBandwidthPerSecond:(unsigned long)bytes;

// Get a rough average (for the last 5 seconds) of how much bandwidth is being used, in bytes
//获得一个粗略的平均(最后5秒)使用多少带宽,在字节
+ (unsigned long)averageBandwidthUsedPerSecond;

- (void)performThrottling;

// Will return YES is bandwidth throttling is currently in use
//将返回是的带宽节流目前正在使用吗
+ (BOOL)isBandwidthThrottled;

// Used internally to record bandwidth use, and by ASIInputStreams when uploading. It's probably best if you don't mess with this.
//在内部使用记录带宽使用,ASIInputStreams上传。可能是最好的如果你别惹这。
+ (void)incrementBandwidthUsedInLastSecond:(unsigned long)bytes;

// On iPhone, ASIHTTPRequest can automatically turn throttling on and off as the connection type changes between WWAN and WiFi
//在iPhone上,ASIHTTPRequest可以自动打开和关闭节流WWAN和WiFi之间的连接类型的变化\

#if TARGET_OS_IPHONE
// Set to YES to automatically turn on throttling when WWAN is connected, and automatically turn it off when it isn't
//设置为YES WWAN连接时自动开启节流,并自动关机的时候不是
+ (void)setShouldThrottleBandwidthForWWAN:(BOOL)throttle;

// Turns on throttling automatically when WWAN is connected using a custom limit, and turns it off automatically when it isn't
//打开时自动节流WWAN连接使用一个自定义的限制,并把它关掉自动当它不是
+ (void)throttleBandwidthForWWANUsingLimit:(unsigned long)limit;

#pragma mark reachability

// Returns YES when an iPhone OS device is connected via WWAN, false when connected via WIFI or not connected
//回报是通过WWAN当iPhone OS设备连接,假当该值通过WIFI连接或不连接
+ (BOOL)isNetworkReachableViaWWAN;

#endif

#pragma mark queue

// Returns the shared queue
//返回共享队列
+ (NSOperationQueue *)sharedQueue;

#pragma mark cache

+ (void)setDefaultCache:(id <ASICacheDelegate>)cache;
+ (id <ASICacheDelegate>)defaultCache;

// Returns the maximum amount of data we can read as part of the current measurement period, and sleeps this thread if our allowance is used up
//返回的数据量我们可以阅读作为当前测量周期的一部分,和睡这个线程如果使用我们的零花钱
+ (unsigned long)maxUploadReadLength;

#pragma mark network activity

+ (BOOL)isNetworkInUse;

+ (void)setShouldUpdateNetworkActivityIndicator:(BOOL)shouldUpdate;

// Shows the network activity spinner thing on iOS. You may wish to override this to do something else in Mac projects
//显示网络活动纺纱机的iOS。您可能希望覆盖这个在Mac做别的项目
+ (void)showNetworkActivityIndicator;

// Hides the network activity spinner thing on iOS
// 隐藏网络活动纺纱机的iOS
+ (void)hideNetworkActivityIndicator;

#pragma mark miscellany

// Used for generating Authorization header when using basic authentication when shouldPresentCredentialsBeforeChallenge is true
//用于生成授权shouldPresentCredentialsBeforeChallenge时头在使用基本身份验证是正确的
// And also by ASIS3Request
// 并通过ASIS3Request
+ (NSString *)base64forData:(NSData *)theData;

// Returns the expiration date for the request.
// Calculated from the Expires response header property, unless maxAge is non-zero or
// there exists a non-zero max-age property in the Cache-Control response header.
/*
 返回请求的过期日期。
 　　计算的响应头产权到期,除非maxAge零或
 　　存在一个非零cache - control响应头信息属性。
 */
+ (NSDate *)expiryDateForRequest:(ASIHTTPRequest *)request maxAge:(NSTimeInterval)maxAge;

// Returns a date from a string in RFC1123 format
// 返回一个字符串的日期RFC1123格式
+ (NSDate *)dateFromRFC1123String:(NSString *)string;


// Used for detecting multitasking support at runtime (for backgrounding requests)
// 用于检测多任务支持在运行时(后台处理请求)
#if TARGET_OS_IPHONE
+ (BOOL)isMultitaskingSupported;
#endif

#pragma mark threading behaviour

// In the default implementation, all requests run in a single background thread
// Advanced users only: Override this method in a subclass for a different threading behaviour
// Eg: return [NSThread mainThread] to run all requests in the main thread
// Alternatively, you can create a thread on demand, or manage a pool of threads
// Threads returned by this method will need to run the runloop in default mode (eg CFRunLoopRun())
// Requests will stop the runloop when they complete
// If you have multiple requests sharing the thread you'll need to restart the runloop when this happens
/*
 / /默认实现,所有请求在一个后台线程运行
 　　/ /高级用户只有:在子类中重写此方法为一个不同的线程的行为
 　　/ /例如:返回[NSThread mainThread]运行在主线程的所有请求
 　　/ /或者,您可以创建一个线程对需求,或管理的线程池
 　　/ /线程返回的这个方法将需要运行runloop默认模式(如CFRunLoopRun())
 　　/ /请求将停止runloop当他们完成
 　　/ /如果你有多个请求共享线程需要重新启动runloop当这一切发生的时候
 */
+ (NSThread *)threadForRequest:(ASIHTTPRequest *)request;


#pragma mark ===

@property (retain) NSString *username;
@property (retain) NSString *password;
@property (retain) NSString *userAgentString;
@property (retain) NSString *domain;

@property (retain) NSString *proxyUsername;
@property (retain) NSString *proxyPassword;
@property (retain) NSString *proxyDomain;

@property (retain) NSString *proxyHost;
@property (assign) int proxyPort;
@property (retain) NSString *proxyType;

@property (retain,setter=setURL:, nonatomic) NSURL *url;
@property (retain) NSURL *originalURL;
@property (assign, nonatomic) id delegate;
@property (retain, nonatomic) id queue;
@property (assign, nonatomic) id uploadProgressDelegate;
@property (assign, nonatomic) id downloadProgressDelegate;
@property (assign) BOOL useKeychainPersistence;
@property (assign) BOOL useSessionPersistence;
@property (retain) NSString *downloadDestinationPath;
@property (retain) NSString *temporaryFileDownloadPath;
@property (retain) NSString *temporaryUncompressedDataDownloadPath;
@property (assign) SEL didStartSelector;
@property (assign) SEL didReceiveResponseHeadersSelector;
@property (assign) SEL willRedirectSelector;
@property (assign) SEL didFinishSelector;
@property (assign) SEL didFailSelector;
@property (assign) SEL didReceiveDataSelector;
@property (retain,readonly) NSString *authenticationRealm;
@property (retain,readonly) NSString *proxyAuthenticationRealm;
@property (retain) NSError *error;
@property (assign,readonly) BOOL complete;
@property (retain) NSDictionary *responseHeaders;
@property (retain) NSMutableDictionary *requestHeaders;
@property (retain) NSMutableArray *requestCookies;
@property (retain,readonly) NSArray *responseCookies;
@property (assign) BOOL useCookiePersistence;
@property (retain) NSDictionary *requestCredentials;
@property (retain) NSDictionary *proxyCredentials;
@property (assign,readonly) int responseStatusCode;
@property (retain,readonly) NSString *responseStatusMessage;
@property (retain) NSMutableData *rawResponseData;
@property (assign) NSTimeInterval timeOutSeconds;
@property (retain, nonatomic) NSString *requestMethod;
@property (retain) NSMutableData *postBody;
@property (assign) unsigned long long contentLength;
@property (assign) unsigned long long postLength;
@property (assign) BOOL shouldResetDownloadProgress;
@property (assign) BOOL shouldResetUploadProgress;
@property (assign) ASIHTTPRequest *mainRequest;
@property (assign) BOOL showAccurateProgress;
@property (assign) unsigned long long totalBytesRead;
@property (assign) unsigned long long totalBytesSent;
@property (assign) NSStringEncoding defaultResponseEncoding;
@property (assign) NSStringEncoding responseEncoding;
@property (assign) BOOL allowCompressedResponse;
@property (assign) BOOL allowResumeForFileDownloads;
@property (retain) NSDictionary *userInfo;
@property (assign) NSInteger tag;
@property (retain) NSString *postBodyFilePath;
@property (assign) BOOL shouldStreamPostDataFromDisk;
@property (assign) BOOL didCreateTemporaryPostDataFile;
@property (assign) BOOL useHTTPVersionOne;
@property (assign, readonly) unsigned long long partialDownloadSize;
@property (assign) BOOL shouldRedirect;
@property (assign) BOOL validatesSecureCertificate;
@property (assign) BOOL shouldCompressRequestBody;
@property (retain) NSURL *PACurl;
@property (retain) NSString *authenticationScheme;
@property (retain) NSString *proxyAuthenticationScheme;
@property (assign) BOOL shouldPresentAuthenticationDialog;
@property (assign) BOOL shouldPresentProxyAuthenticationDialog;
@property (assign, readonly) ASIAuthenticationState authenticationNeeded;
@property (assign) BOOL shouldPresentCredentialsBeforeChallenge;
@property (assign, readonly) int authenticationRetryCount;
@property (assign, readonly) int proxyAuthenticationRetryCount;
@property (assign) BOOL haveBuiltRequestHeaders;
@property (assign, nonatomic) BOOL haveBuiltPostBody;
@property (assign, readonly) BOOL inProgress;
@property (assign) int numberOfTimesToRetryOnTimeout;
@property (assign, readonly) int retryCount;
@property (assign) BOOL shouldAttemptPersistentConnection;
@property (assign) NSTimeInterval persistentConnectionTimeoutSeconds;
@property (assign) BOOL shouldUseRFC2616RedirectBehaviour;
@property (assign, readonly) BOOL connectionCanBeReused;
@property (retain, readonly) NSNumber *requestID;
@property (assign) id <ASICacheDelegate> downloadCache;
@property (assign) ASICachePolicy cachePolicy;
@property (assign) ASICacheStoragePolicy cacheStoragePolicy;
@property (assign, readonly) BOOL didUseCachedResponse;
@property (assign) NSTimeInterval secondsToCache;
@property (retain) NSArray *clientCertificates;
#if TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_4_0
@property (assign) BOOL shouldContinueWhenAppEntersBackground;
#endif
@property (retain) ASIDataDecompressor *dataDecompressor;
@property (assign) BOOL shouldWaitToInflateCompressedResponses;

@end
